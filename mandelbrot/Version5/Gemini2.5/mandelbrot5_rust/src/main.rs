use num_complex::Complex;
use rayon::prelude::*;
use std::io::{self, Write};

/// Calculates the pixel data for a single row of the Mandelbrot set image.
///
/// Each row is a vector of bytes, where each bit corresponds to a pixel.
/// A bit is set to 1 if the point is in the set, and 0 otherwise.
fn calculate_row(y: usize, size: usize) -> Vec<u8> {
    // Pre-calculate constants for this row
    let inv_size = 2.0 / size as f64;
    let y_im = inv_size * y as f64 - 1.0;

    // We need ceil(size / 8) bytes per row.
    let mut row_data = Vec::with_capacity((size + 7) / 8);

    // Process pixels in chunks of 8 to build up each byte.
    for x_chunk_start in (0..size).step_by(8) {
        let mut byte_acc = 0u8;
        // Calculate the 8 bits for the current byte.
        for i in 0..8 {
            let x_pixel = x_chunk_start + i;
            // Stop if we've gone past the image width.
            if x_pixel >= size {
                break;
            }

            let c = Complex::new(inv_size * x_pixel as f64 - 1.5, y_im);
            let mut z = Complex::new(0.0, 0.0);

            // Check if the point is in the Mandelbrot set.
            // This is equivalent to the Python code's `for...else` logic.
            let mut is_in_set = true;
            for _ in 0..50 {
                z = z * z + c;
                if z.norm_sqr() > 4.0 {
                    is_in_set = false;
                    break;
                }
            }

            if is_in_set {
                // Set the bit. PBM format is big-endian, so we shift from the left.
                byte_acc |= 1 << (7 - i);
            }
        }
        row_data.push(byte_acc);
    }
    row_data
}

fn main() {
    // 1. Get image size from command-line arguments, default to 200.
    let size = std::env::args()
        .nth(1)
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(200);

    // 2. Lock stdout for buffered writing and print the PBM header.
    let mut stdout = io::stdout().lock();
    // The P4 format is for a portable bitmap (black and white).
    writeln!(stdout, "P4\n{} {}", size, size).unwrap();

    // 3. Generate all rows in parallel using Rayon.
    // Rayon's `into_par_iter()` automatically distributes the work
    // of the `map` operation across multiple threads.
    let rows: Vec<Vec<u8>> = (0..size)
        .into_par_iter()
        .map(|y| calculate_row(y, size))
        .collect();

    // 4. Write the generated byte data for each row to standard output.
    for row in rows {
        stdout.write_all(&row).unwrap();
    }
}
