#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <pthread.h>
#include <sys/sysinfo.h>
#include <assert.h>

// Type definition for task arguments
typedef struct {
    int n;
    long start_index;
    long size;
    long checksum;
    int max_flips;
} task_arg_t;

// Global array for factorials up to 16
long factorials[17];

// Function to calculate and store factorials
void precompute_factorials(int n) {
    factorials[0] = 1;
    for (int i = 1; i <= n; i++) {
        factorials[i] = factorials[i-1] * i;
    }
}

// Function to reverse the prefix of a permutation
void flip(int n, unsigned char* p) {
    int i, temp;
    for (i = 0; i < n / 2; i++) {
        temp = p[i];
        p[i] = p[n - 1 - i];
        p[n - 1 - i] = temp;
    }
}

// Generates the k-th permutation based on the index (start_index)
// and stores it in the 'p' array.
void get_nth_permutation(int n, long start_index, unsigned char* p) {
    long remainder = start_index;
    int count[17] = {0}; // Holds the counts for the mixed-radix number system

    // Initialize the permutation 'p' to [0, 1, 2, ...]
    for (int i = 0; i < n; i++) {
        p[i] = i;
    }

    // Convert start_index to mixed-radix
    for (int v = n - 1; v > 0; v--) {
        // Calculate count[v] and the new remainder
        count[v] = remainder / factorials[v];
        remainder = remainder % factorials[v];

        // Apply the rotations based on count[v]
        for (int i = 0; i < count[v]; i++) {
            unsigned char first = p[0];
            memmove(p, p + 1, v * sizeof(unsigned char));
            p[v] = first;
        }
    }
}

// Performs one step of the Fannkuch sequence generation and calculation
void *fannkuch_task(void *arg) {
    task_arg_t *task_arg = (task_arg_t *)arg;
    int n = task_arg->n;
    long start_index = task_arg->start_index;
    long size = task_arg->size;

    long checksum = 0;
    int max_flips = 0;
    int alternating_factor = 1;

    // The current permutation array
    unsigned char p[17];
    // A temporary array to store the original state for flips
    unsigned char temp_p[17];

    // 1. Get the starting permutation
    get_nth_permutation(n, start_index, p);

    // 2. Main loop over the task's slice of permutations
    for (long i = 0; i < size; i++) {
        // 'p' is the current permutation, copy it to 'temp_p' for flipping
        memcpy(temp_p, p, n * sizeof(unsigned char));
        
        int first = temp_p[0];
        if (first != 0) {
            int flips_count = 0;
            do {
                // Flip the prefix of length 'first + 1'
                // The C flip function will only flip the prefix of temp_p
                // The indices are 0 to first (length is first + 1)
                for (int j = 0; j < (first + 1) / 2; j++) {
                    unsigned char swap = temp_p[j];
                    temp_p[j] = temp_p[first - j];
                    temp_p[first - j] = swap;
                }
                flips_count++;
                first = temp_p[0]; // New length
            } while (first != 0);

            // Update max_flips and checksum
            if (max_flips < flips_count) {
                max_flips = flips_count;
            }
            checksum += flips_count * alternating_factor;
        } else {
            checksum += 0; // Alternating factor * 0
        }
        
        // Update alternating factor
        alternating_factor = -alternating_factor;

        // 3. Get the *next* permutation in the lexicographical order
        // This logic is simplified from the Python version's 'permutations' generator
        // which used mixed-radix number system to advance.
        
        // This section implements the logic to find the next permutation
        // The Python code: 'p[0], p[1] = p[1], p[0]' then an iterative carry/rotation.
        // The C code for the next permutation will be complex to implement efficiently 
        // using the *exact* same method as Python's mixed-radix state update
        // for every step. The provided Python implementation is an optimized 'next' 
        // function that applies the next rotation *and* the preceding rotation logic 
        // to maintain the correct state for the *next* task element efficiently.
        // A full conversion would require replicating the 'rotation_swaps' and 'count' 
        // logic. 
        
        // For a more standard C implementation, we'll use an array 'count' (like Python)
        // to track the mixed-radix state and advance it.
        
        // Since we are not fully replicating the stateful Python generator, 
        // the most robust C approach for general-purpose high-performance Fannkuch
        // is to use the **initial state + index offset** approach for the starting
        // permutation, and then, for the subsequent permutations in the slice, 
        // either re-calculate or implement a fast next-permutation algorithm.
        
        // Given the constraints of a direct port and the complexity of the Python's 
        // 'permutations' generator's internal state machine, we will rely on 
        // calculating the N-th permutation at the *start* of the slice, and
        // simply calculate the next index's permutation directly if a full state 
        // port is too complex/error-prone (which is the case for a quick port).
        
        // **Simplified Next Permutation Logic (for demonstration):**
        // Since the Python code uses `islice(permutations(n, start, size), size)`, 
        // the simplest way to advance is by re-calculating the permutation for 
        // `start_index + i + 1`. This is slow but correct. 
        // *Optimized C Fannkuch code uses a highly efficient in-place state update.*
        
        // For correctness: The next permutation is at index (start_index + i + 1)
        if (i < size - 1) {
             get_nth_permutation(n, start_index + i + 1, p);
        }
    }

    // Store results back into the argument structure
    task_arg->checksum = checksum;
    task_arg->max_flips = max_flips;
    return NULL;
}

// Main function
void fannkuch_main(int n) {
    if (n < 0 || n > 16) { // Max factorial is around 20, 16 is a safe limit for `long`
        fprintf(stderr, "N must be between 1 and 16 for this implementation.\n");
        return;
    }
    
    precompute_factorials(n);
    long total_permutations = factorials[n];
    
    int task_count = get_nprocs(); // Get number of available processors
    long task_size = (total_permutations + task_count - 1) / task_count;

    // Apply the Python logic for task size adjustment
    if (task_size < 20000) {
        task_size = total_permutations;
        task_count = 1;
    }

    // Ensure task_size is even as per Python's assert
    if (task_size % 2 != 0) {
        if (task_count > 1) {
            task_size++; // Adjust to next even number
            if (task_size > total_permutations) {
                task_size = total_permutations;
            }
        }
    }
    
    // Recalculate task_count after task_size adjustment
    task_count = (total_permutations + task_size - 1) / task_size;
    
    // --- Thread/Task Setup ---
    pthread_t threads[task_count];
    task_arg_t task_args[task_count];
    
    for (int i = 0; i < task_count; i++) {
        task_args[i].n = n;
        task_args[i].start_index = (long)i * task_size;
        
        // The size for the last task might be smaller
        long current_size = task_size;
        if (task_args[i].start_index + task_size > total_permutations) {
            current_size = total_permutations - task_args[i].start_index;
        }
        task_args[i].size = current_size;
        
        task_args[i].checksum = 0;
        task_args[i].max_flips = 0;

        // Create the thread
        if (pthread_create(&threads[i], NULL, fannkuch_task, &task_args[i]) != 0) {
            perror("Failed to create thread");
            return;
        }
    }

    // --- Wait for Threads and Aggregate Results ---
    long final_checksum = 0;
    int final_max_flips = 0;

    for (int i = 0; i < task_count; i++) {
        pthread_join(threads[i], NULL);
        final_checksum += task_args[i].checksum;
        if (task_args[i].max_flips > final_max_flips) {
            final_max_flips = task_args[i].max_flips;
        }
    }

    // --- Output ---
    printf("%ld\nPfannkuchen(%d) = %d\n", final_checksum, n, final_max_flips);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <N>\n", argv[0]);
        return 1;
    }
    
    int n = atoi(argv[1]);
    
    // The Python code prints permutations if N < 0, but this is a *performance* port.
    if (n < 1) { 
        fprintf(stderr, "N must be a positive integer for the performance benchmark.\n");
        return 1;
    }
    
    fannkuch_main(n);
    
    return 0;
}
