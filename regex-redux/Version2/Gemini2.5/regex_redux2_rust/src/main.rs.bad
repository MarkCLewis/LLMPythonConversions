use pcre2::bytes::{Regex, RegexBuilder};
use rayon::prelude::*;
use std::io::{self, Read};

fn main() {
    // Read all input from stdin into a byte vector. Working with bytes ([u8])
    // is faster as it avoids UTF-8 validation and matches the Python script's
    // use of byte strings.
    let mut input = Vec::new();
    io::stdin().lock().read_to_end(&mut input).unwrap();
    let initial_len = input.len();

    // Task 1: Clean the input by removing FASTA sequence descriptions and newlines.
    // This uses a PCRE2 regex with JIT enabled for maximum speed.
    let cleaner_re = RegexBuilder::new().jit(true).build(b">.*\\n|\\n").unwrap();
    let sequences = cleaner_re.replace_all(b"", &input).into_owned();
    let cleaned_len = sequences.len();

    // Task 2: Perform a series of replacements serially.
    // This section mimics the Python script's logic where one worker performs
    // all replacements sequentially.
    let final_len = {
        let replacements = [
            (b"tHa[Nt]", b"<4>"),
            (b"aND|caN|Ha[DS]|WaS", b"<3>"),
            (b"a[NSt]|BY", b"<2>"),
            (b"<[^>]*>", b"|"),
            (b"\\|[^|][^|]*\\|", b"-"),
        ];

        // To avoid reallocating a new string for each replacement, we use a
        // double-buffer technique, alternating between writing from one buffer
        // to the other. This is more memory-efficient.
        let mut buffer1 = sequences.clone();
        let mut buffer2 = Vec::with_capacity(buffer1.len());

        for (i, (pattern, replacement)) in replacements.iter().enumerate() {
            let re = RegexBuilder::new().jit(true).build(pattern).unwrap();
            if i % 2 == 0 {
                // On even iterations, replace from buffer1 into buffer2.
                buffer2.clear();
                re.replace_all_to(replacement, &buffer1, &mut buffer2);
            } else {
                // On odd iterations, replace from buffer2 into buffer1.
                buffer1.clear();
                re.replace_all_to(replacement, &buffer2, &mut buffer1);
            }
        }

        // The final result is in buffer2 because there are 5 (an odd number) replacements.
        if replacements.len() % 2 == 1 {
            buffer2.len()
        } else {
            buffer1.len()
        }
    };

    // Task 3: Count occurrences of various patterns in parallel.
    // The rayon crate's parallel iterator (`par_iter`) automatically distributes
    // the work across a thread pool.
    let count_patterns = [
        b"agggtaaa|tttaccct",
        b"[cgt]gggtaaa|tttaccc[acg]",
        b"a[act]ggtaaa|tttacc[agt]t",
        b"ag[act]gtaaa|tttac[agt]ct",
        b"agg[act]taaa|ttta[agt]cct",
        b"aggg[acg]aaa|ttt[cgt]ccct",
        b"agggt[cgt]aa|tt[acg]accct",
        b"agggta[cgt]a|t[acg]taccct",
        b"agggtaa[cgt]|[acg]ttaccct",
    ];

    let counts: Vec<usize> = count_patterns
        .par_iter()
        .map(|pattern| {
            let re = RegexBuilder::new().jit(true).build(pattern).unwrap();
            // The `find_iter` method returns an iterator over all non-overlapping
            // matches, which we can simply count.
            re.find_iter(&sequences).count()
        })
        .collect();

    // Print the results in the required format.
    for (pattern, count) in count_patterns.iter().zip(counts) {
        // Use from_utf8_lossy to safely convert the byte-string pattern for printing.
        println!("{} {}", String::from_utf8_lossy(pattern), count);
    }
    println!();
    println!("{}", initial_len);
    println!("{}", cleaned_len);
    println!("{}", final_len);
}
